{
  "name": "Local AI Agent (Cloud-based)",
  "nodes": [
    {
      "parameters": {
        "path": "telegram-ai-agent-cloud",
        "httpMethod": "POST",
        "responseMode": "onReceived",
        "options": {}
      },
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        -520,
        300
      ],
      "webhookId": "telegram-ai-agent-cloud"
    },
    {
      "parameters": {
        "functionCode": "const body = $json.body || {};\nconst message = body.message || {};\nconst chat = message.chat || {};\nconst text = message.text || '';\nconst document = message.document;\n\nconst isWebSearch = text.startsWith('/search ');\nconst isDocument = !!document;\n\nreturn [{\n  chatId: chat.id,\n  originalText: text,\n  isWebSearch,\n  isDocument,\n  document,\n  query: isWebSearch ? text.replace('/search ', '') : text\n}];"
      },
      "name": "Parse Telegram",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        -300,
        300
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "Thinking...",
        "additionalFields": {}
      },
      "name": "Telegram Typing",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1,
      "position": [
        -90,
        140
      ],
      "credentials": {
        "telegramApi": {
          "id": "TELEGRAM_CREDENTIALS_ID",
          "name": "Telegram"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.isDocument }}",
              "value2": true
            }
          ],
          "string": []
        }
      },
      "name": "If Document",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        -90,
        560
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.isWebSearch }}",
              "value2": true
            }
          ],
          "string": []
        }
      },
      "name": "If Web Search",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        90,
        420
      ]
    },
    {
      "parameters": {
        "requestMethod": "GET",
        "url": "={{ 'https://api.telegram.org/bot' + $env.TELEGRAM_TOKEN + '/getFile' }}",
        "jsonParameters": true,
        "options": {},
        "sendQuery": true,
        "queryParametersJson": "={{ JSON.stringify({ \"file_id\": $json.document.file_id }) }}"
      },
      "name": "Get File Path",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        200,
        700
      ]
    },
    {
      "parameters": {
        "requestMethod": "GET",
        "url": "={{ 'https://api.telegram.org/file/bot' + $env.TELEGRAM_TOKEN + '/' + $json.result.file_path }}",
        "jsonParameters": true,
        "options": {},
        "responseFormat": "string"
      },
      "name": "Download File",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        400,
        700
      ]
    },
    {
      "parameters": {
        "functionCode": "const text = $json.data || '';\nconst chunkSize = 1000;\nconst chunks = [];\nconst paragraphs = text.split(/\\n\\s*\\n/);\nlet currentChunk = '';\nfor (const p of paragraphs) {\n  if ((currentChunk + p).length > chunkSize) {\n    if (currentChunk) chunks.push(currentChunk.trim());\n    currentChunk = p;\n  } else {\n    currentChunk += (currentChunk ? '\\n\\n' : '') + p;\n  }\n}\nif (currentChunk) chunks.push(currentChunk.trim());\nif (chunks.length === 0 && text.length > 0) {\n  for (let i = 0; i < text.length; i += chunkSize) {\n    chunks.push(text.slice(i, i + chunkSize));\n  }\n}\nreturn chunks.map((chunk, index) => ({\n  chunk,\n  chunkIndex: index,\n  totalChunks: chunks.length,\n  fileName: $node[\"Parse Telegram\"].json.document.file_name,\n  chatId: $node[\"Parse Telegram\"].json.chatId\n}));"
      },
      "name": "Split Text",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        600,
        700
      ]
    },
    {
      "parameters": {
        "requestMethod": "POST",
        "url": "https://api.openai.com/v1/embeddings",
        "jsonParameters": true,
        "options": {},
        "headerParameters": [
          {
            "name": "Authorization",
            "value": "={{ 'Bearer ' + $env.OPENAI_API_KEY }}"
          }
        ],
        "bodyParametersJson": "={{ JSON.stringify({\n  \"model\": ($env.OPENAI_EMBEDDING_MODEL || \"text-embedding-3-small\"),\n  \"input\": $json.chunk\n}) }}"
      },
      "name": "OpenAI Embed Chunk",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        800,
        700
      ]
    },
    {
      "parameters": {
        "requestMethod": "POST",
        "url": "={{ 'http://chroma:8000/api/v1/collections/' + $('Merge Collection ID').first().json.collectionId + '/upsert' }}",
        "jsonParameters": true,
        "options": {},
        "bodyParametersJson": "={{ JSON.stringify({\n  \"ids\": [ $('Parse Telegram').first().json.document.file_id + '_' + $json.chunkIndex ],\n  \"embeddings\": [ $json.data[0].embedding ],\n  \"documents\": [ $json.chunk ],\n  \"metadatas\": [ { \"source\": \"file\", \"filename\": $json.fileName } ]\n}) }}"
      },
      "name": "Upsert Chunk",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        1000,
        700
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $('Parse Telegram').first().json.chatId }}",
        "text": "={{ 'I have read \"' + $('Parse Telegram').first().json.document.file_name + '\". Processed ' + ($('Split Text').item.json.chunkIndex + 1) + ' of ' + $('Split Text').item.json.totalChunks + ' chunks.' }}",
        "additionalFields": {}
      },
      "name": "Notify Progress",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1,
      "position": [
        1200,
        700
      ],
      "credentials": {
        "telegramApi": {
          "id": "TELEGRAM_CREDENTIALS_ID",
          "name": "Telegram"
        }
      }
    },
    {
      "parameters": {
        "requestMethod": "POST",
        "url": "http://chroma:8000/api/v1/collections",
        "jsonParameters": true,
        "options": {},
        "bodyParametersJson": "{\"name\": \"ai_memory\", \"get_or_create\": true}"
      },
      "name": "Get Collection",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        -200,
        420
      ]
    },
    {
      "parameters": {
        "functionCode": "const original = $node[\"Parse Telegram\"].json;\nconst collection = $json;\nreturn [{ ...original, collectionId: collection.id }];"
      },
      "name": "Merge Collection ID",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        200,
        420
      ]
    },
    {
      "parameters": {
        "requestMethod": "POST",
        "url": "https://api.openai.com/v1/embeddings",
        "jsonParameters": true,
        "options": {},
        "headerParameters": [
          {
            "name": "Authorization",
            "value": "={{ 'Bearer ' + $env.OPENAI_API_KEY }}"
          }
        ],
        "bodyParametersJson": "={{ JSON.stringify({\n  \"model\": ($env.OPENAI_EMBEDDING_MODEL || \"text-embedding-3-small\"),\n  \"input\": $json.query\n}) }}"
      },
      "name": "OpenAI Generate Query Embedding",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        140,
        220
      ]
    },
    {
      "parameters": {
        "requestMethod": "POST",
        "url": "={{ 'http://chroma:8000/api/v1/collections/' + $node[\"Merge Collection ID\"].json.collectionId + '/query' }}",
        "jsonParameters": true,
        "options": {},
        "bodyParametersJson": "={{ JSON.stringify({ \"query_embeddings\": [ $json.data[0].embedding ], \"n_results\": 3 }) }}"
      },
      "name": "Chroma Query",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        340,
        220
      ]
    },
    {
      "parameters": {
        "functionCode": "const results = $json.documents || [];\nlet context = '';\nif (Array.isArray(results) && results.length > 0) {\n  const docs = results[0];\n  if (Array.isArray(docs)) {\n    context = docs.join('\\n');\n  }\n}\nconst originalData = $('Parse Telegram').first().json;\nreturn [{\n  chatId: originalData.chatId,\n  originalText: originalData.originalText,\n  query: originalData.query,\n  isWebSearch: originalData.isWebSearch,\n  memoryContext: context\n}];"
      },
      "name": "Build RAG Context",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        540,
        220
      ]
    },
    {
      "parameters": {
        "requestMethod": "POST",
        "url": "https://api.tavily.com/search",
        "jsonParameters": true,
        "options": {},
        "bodyParametersJson": "={{ JSON.stringify({\n  \"api_key\": $env.TAVILY_API_KEY,\n  \"query\": $json.query,\n  \"search_depth\": \"advanced\",\n  \"max_results\": 7,\n  \"include_answer\": true,\n  \"include_raw_content\": true\n}) }}"
      },
      "name": "Tavily Search",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        140,
        520
      ]
    },
    {
      "parameters": {
        "functionCode": "let webContext = '';\nif ($json.answer) {\n  webContext += `Tavily Direct Answer:\\n${$json.answer}\\n\\n`;\n}\nif (Array.isArray($json.results)) {\n  webContext += \"Search Results:\\n\";\n  webContext += $json.results.map((r, i) => `[${i+1}] Title: ${r.title}\\nURL: ${r.url}\\nContent: ${r.content}`).join('\\n\\n');\n}\nconst originalData = $('Parse Telegram').first().json;\nreturn [{\n  chatId: originalData.chatId,\n  originalText: originalData.originalText,\n  query: originalData.query,\n  memoryContext: '',\n  webContext\n}];"
      },
      "name": "Build Web Context",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        360,
        520
      ]
    },
    {
      "parameters": {
        "functionCode": "const system = 'Ты русскоязычный ассистент в Telegram. Отвечай строго по \\\"Web search context\\\". Не используй внешние знания. Если ответа нет в контексте, прямо скажи об этом. Приводи ссылки на источники в формате [1], [2]. Будь краток.';\nconst parts = [];\nif ($json.memoryContext) {\n  parts.push('Memory context:\\n' + $json.memoryContext);\n}\nif ($json.webContext) {\n  parts.push('Web search context:\\n' + $json.webContext);\n}\nconst context = parts.join('\\n\\n');\nlet content = '';\nif (context) {\n  content = `<<CONTEXT_START>>\\n${context}\\n<<CONTEXT_END>>\\n\\nВопрос: ${$json.query}\\nОтвет:`;\n} else {\n  content = `Вопрос: ${$json.query}\\nОтвет:`;\n}\nreturn [{\n  chatId: $json.chatId,\n  prompt: content,\n  system,\n  query: $json.query\n}];"
      },
      "name": "Build Prompt",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        580,
        340
      ]
    },
    {
      "parameters": {
        "requestMethod": "POST",
        "url": "https://api.openai.com/v1/chat/completions",
        "jsonParameters": true,
        "options": {},
        "headerParameters": [
          {
            "name": "Authorization",
            "value": "={{ 'Bearer ' + $env.OPENAI_API_KEY }}"
          }
        ],
        "bodyParametersJson": "={{ JSON.stringify({\n  \"model\": ($env.OPENAI_MODEL || \"gpt-4o-mini\"),\n  \"temperature\": 0,\n  \"messages\": [\n    {\"role\": \"system\", \"content\": $json.system},\n    {\"role\": \"user\", \"content\": $json.prompt}\n  ]\n}) }}"
      },
      "name": "OpenAI Chat",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        800,
        340
      ]
    },
    {
      "parameters": {
        "functionCode": "const resp = $json;\nlet llmAnswer = '';\ntry {\n  if (resp.choices && resp.choices[0] && resp.choices[0].message && resp.choices[0].message.content) {\n    llmAnswer = resp.choices[0].message.content;\n  }\n} catch (e) {}\nif (!llmAnswer && resp.error) {\n  llmAnswer = \"Ошибка от AI: \" + JSON.stringify(resp.error);\n}\nif (!llmAnswer) {\n  llmAnswer = \"Нет ответа от AI. Исходный ответ: \" + JSON.stringify(resp);\n}\nlet tavilyAnswer = '';\ntry {\n  const t = $('Tavily Search').first().json;\n  if (t && t.answer) tavilyAnswer = t.answer;\n} catch (e) {}\nconst finalAnswer = tavilyAnswer || llmAnswer;\nconst originalData = $('Parse Telegram').first().json;\nconst promptData = $('Build Prompt').first().json;\nreturn [{\n  chatId: originalData.chatId,\n  answer: finalAnswer,\n  question: promptData.query\n}];"
      },
      "name": "Extract Answer",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1020,
        340
      ]
    },
    {
      "parameters": {
        "requestMethod": "POST",
        "url": "https://api.openai.com/v1/embeddings",
        "jsonParameters": true,
        "options": {},
        "headerParameters": [
          {
            "name": "Authorization",
            "value": "={{ 'Bearer ' + $env.OPENAI_API_KEY }}"
          }
        ],
        "bodyParametersJson": "={{ JSON.stringify({\n  \"model\": ($env.OPENAI_EMBEDDING_MODEL || \"text-embedding-3-small\"),\n  \"input\": ($json.question + \"\\n\\n\" + $json.answer).substring(0, 4000)\n}) }}"
      },
      "name": "OpenAI Generate Answer Embedding",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        1240,
        220
      ]
    },
    {
      "parameters": {
        "requestMethod": "POST",
        "url": "={{ 'http://chroma:8000/api/v1/collections/' + $('Merge Collection ID').first().json.collectionId + '/upsert' }}",
        "jsonParameters": true,
        "options": {},
        "bodyParametersJson": "={{ JSON.stringify({\n  \"ids\": [ Date.now().toString() ],\n  \"embeddings\": [ $json.data[0].embedding ],\n  \"documents\": [ $('Extract Answer').first().json.question + \"\\n\\n\" + $('Extract Answer').first().json.answer ],\n  \"metadatas\": [ { \"source\": \"telegram\" } ]\n}) }}"
      },
      "name": "Chroma Upsert",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        1440,
        220
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{ $json.answer }}",
        "additionalFields": {}
      },
      "name": "Telegram Send Answer",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1,
      "position": [
        1640,
        460
      ],
      "credentials": {
        "telegramApi": {
          "id": "TELEGRAM_CREDENTIALS_ID",
          "name": "Telegram"
        }
      }
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Parse Telegram",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Telegram": {
      "main": [
        [
          {
            "node": "Telegram Typing",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Collection",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Collection": {
      "main": [
        [
          {
            "node": "Merge Collection ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Collection ID": {
      "main": [
        [
          {
            "node": "If Document",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Document": {
      "main": [
        [
          {
            "node": "Get File Path",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If Web Search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Web Search": {
      "main": [
        [
          {
            "node": "Tavily Search",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "OpenAI Generate Query Embedding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Generate Query Embedding": {
      "main": [
        [
          {
            "node": "Chroma Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chroma Query": {
      "main": [
        [
          {
            "node": "Build RAG Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Tavily Search": {
      "main": [
        [
          {
            "node": "Build Web Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build RAG Context": {
      "main": [
        [
          {
            "node": "Build Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Web Context": {
      "main": [
        [
          {
            "node": "Build Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Prompt": {
      "main": [
        [
          {
            "node": "OpenAI Chat",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat": {
      "main": [
        [
          {
            "node": "Extract Answer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Answer": {
      "main": [
        [
          {
            "node": "OpenAI Generate Answer Embedding",
            "type": "main",
            "index": 0
          },
          {
            "node": "Telegram Send Answer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Generate Answer Embedding": {
      "main": [
        [
          {
            "node": "Chroma Upsert",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get File Path": {
      "main": [
        [
          {
            "node": "Download File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download File": {
      "main": [
        [
          {
            "node": "Split Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Text": {
      "main": [
        [
          {
            "node": "OpenAI Embed Chunk",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Embed Chunk": {
      "main": [
        [
          {
            "node": "Upsert Chunk",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upsert Chunk": {
      "main": [
        [
          {
            "node": "Notify Progress",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {}
}
